// Generated by gencpp from file bmirobot_msg/Robot_fdstatus.msg
// DO NOT EDIT!


#ifndef BMIROBOT_MSG_MESSAGE_ROBOT_FDSTATUS_H
#define BMIROBOT_MSG_MESSAGE_ROBOT_FDSTATUS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace bmirobot_msg
{
template <class ContainerAllocator>
struct Robot_fdstatus_
{
  typedef Robot_fdstatus_<ContainerAllocator> Type;

  Robot_fdstatus_()
    : mt_mode()
    , mt_Gpst()
    , mt_Cpst()
    , mt_Lpst()
    , mt_Gspd()
    , mt_Cspd()
    , mt_Lspd()
    , mt_Gtq()
    , mt_PWMduty()
    , mt_Gtime()
    , mt_Ctime()
    , mt_Rtime()
    , mt_sysclk()
    , mt_smptime()
    , mt_cputmp()
    , mt_mttmp()
    , mt_invlt()
    , mt_incrt()
    , mt_PWMfrq()
    , mt_ecd()
    , mt_ecdcnt()  {
      mt_mode.assign(0);

      mt_Gpst.assign(0);

      mt_Cpst.assign(0);

      mt_Lpst.assign(0);

      mt_Gspd.assign(0);

      mt_Cspd.assign(0);

      mt_Lspd.assign(0);

      mt_Gtq.assign(0);

      mt_PWMduty.assign(0);

      mt_Gtime.assign(0);

      mt_Ctime.assign(0);

      mt_Rtime.assign(0);

      mt_sysclk.assign(0);

      mt_smptime.assign(0);

      mt_cputmp.assign(0);

      mt_mttmp.assign(0);

      mt_invlt.assign(0);

      mt_incrt.assign(0);

      mt_PWMfrq.assign(0);

      mt_ecd.assign(0);

      mt_ecdcnt.assign(0);
  }
  Robot_fdstatus_(const ContainerAllocator& _alloc)
    : mt_mode()
    , mt_Gpst()
    , mt_Cpst()
    , mt_Lpst()
    , mt_Gspd()
    , mt_Cspd()
    , mt_Lspd()
    , mt_Gtq()
    , mt_PWMduty()
    , mt_Gtime()
    , mt_Ctime()
    , mt_Rtime()
    , mt_sysclk()
    , mt_smptime()
    , mt_cputmp()
    , mt_mttmp()
    , mt_invlt()
    , mt_incrt()
    , mt_PWMfrq()
    , mt_ecd()
    , mt_ecdcnt()  {
  (void)_alloc;
      mt_mode.assign(0);

      mt_Gpst.assign(0);

      mt_Cpst.assign(0);

      mt_Lpst.assign(0);

      mt_Gspd.assign(0);

      mt_Cspd.assign(0);

      mt_Lspd.assign(0);

      mt_Gtq.assign(0);

      mt_PWMduty.assign(0);

      mt_Gtime.assign(0);

      mt_Ctime.assign(0);

      mt_Rtime.assign(0);

      mt_sysclk.assign(0);

      mt_smptime.assign(0);

      mt_cputmp.assign(0);

      mt_mttmp.assign(0);

      mt_invlt.assign(0);

      mt_incrt.assign(0);

      mt_PWMfrq.assign(0);

      mt_ecd.assign(0);

      mt_ecdcnt.assign(0);
  }



   typedef boost::array<int32_t, 9>  _mt_mode_type;
  _mt_mode_type mt_mode;

   typedef boost::array<int32_t, 9>  _mt_Gpst_type;
  _mt_Gpst_type mt_Gpst;

   typedef boost::array<int32_t, 9>  _mt_Cpst_type;
  _mt_Cpst_type mt_Cpst;

   typedef boost::array<int32_t, 9>  _mt_Lpst_type;
  _mt_Lpst_type mt_Lpst;

   typedef boost::array<int32_t, 9>  _mt_Gspd_type;
  _mt_Gspd_type mt_Gspd;

   typedef boost::array<int32_t, 9>  _mt_Cspd_type;
  _mt_Cspd_type mt_Cspd;

   typedef boost::array<int32_t, 9>  _mt_Lspd_type;
  _mt_Lspd_type mt_Lspd;

   typedef boost::array<int32_t, 9>  _mt_Gtq_type;
  _mt_Gtq_type mt_Gtq;

   typedef boost::array<int32_t, 9>  _mt_PWMduty_type;
  _mt_PWMduty_type mt_PWMduty;

   typedef boost::array<int32_t, 9>  _mt_Gtime_type;
  _mt_Gtime_type mt_Gtime;

   typedef boost::array<int32_t, 9>  _mt_Ctime_type;
  _mt_Ctime_type mt_Ctime;

   typedef boost::array<int32_t, 9>  _mt_Rtime_type;
  _mt_Rtime_type mt_Rtime;

   typedef boost::array<int32_t, 9>  _mt_sysclk_type;
  _mt_sysclk_type mt_sysclk;

   typedef boost::array<int32_t, 9>  _mt_smptime_type;
  _mt_smptime_type mt_smptime;

   typedef boost::array<int32_t, 9>  _mt_cputmp_type;
  _mt_cputmp_type mt_cputmp;

   typedef boost::array<int32_t, 9>  _mt_mttmp_type;
  _mt_mttmp_type mt_mttmp;

   typedef boost::array<int32_t, 9>  _mt_invlt_type;
  _mt_invlt_type mt_invlt;

   typedef boost::array<int32_t, 9>  _mt_incrt_type;
  _mt_incrt_type mt_incrt;

   typedef boost::array<int32_t, 9>  _mt_PWMfrq_type;
  _mt_PWMfrq_type mt_PWMfrq;

   typedef boost::array<int32_t, 9>  _mt_ecd_type;
  _mt_ecd_type mt_ecd;

   typedef boost::array<int32_t, 9>  _mt_ecdcnt_type;
  _mt_ecdcnt_type mt_ecdcnt;





  typedef boost::shared_ptr< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> const> ConstPtr;

}; // struct Robot_fdstatus_

typedef ::bmirobot_msg::Robot_fdstatus_<std::allocator<void> > Robot_fdstatus;

typedef boost::shared_ptr< ::bmirobot_msg::Robot_fdstatus > Robot_fdstatusPtr;
typedef boost::shared_ptr< ::bmirobot_msg::Robot_fdstatus const> Robot_fdstatusConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator1> & lhs, const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator2> & rhs)
{
  return lhs.mt_mode == rhs.mt_mode &&
    lhs.mt_Gpst == rhs.mt_Gpst &&
    lhs.mt_Cpst == rhs.mt_Cpst &&
    lhs.mt_Lpst == rhs.mt_Lpst &&
    lhs.mt_Gspd == rhs.mt_Gspd &&
    lhs.mt_Cspd == rhs.mt_Cspd &&
    lhs.mt_Lspd == rhs.mt_Lspd &&
    lhs.mt_Gtq == rhs.mt_Gtq &&
    lhs.mt_PWMduty == rhs.mt_PWMduty &&
    lhs.mt_Gtime == rhs.mt_Gtime &&
    lhs.mt_Ctime == rhs.mt_Ctime &&
    lhs.mt_Rtime == rhs.mt_Rtime &&
    lhs.mt_sysclk == rhs.mt_sysclk &&
    lhs.mt_smptime == rhs.mt_smptime &&
    lhs.mt_cputmp == rhs.mt_cputmp &&
    lhs.mt_mttmp == rhs.mt_mttmp &&
    lhs.mt_invlt == rhs.mt_invlt &&
    lhs.mt_incrt == rhs.mt_incrt &&
    lhs.mt_PWMfrq == rhs.mt_PWMfrq &&
    lhs.mt_ecd == rhs.mt_ecd &&
    lhs.mt_ecdcnt == rhs.mt_ecdcnt;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator1> & lhs, const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace bmirobot_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "96575b502188e773da8e23f3a4f7ae68";
  }

  static const char* value(const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x96575b502188e773ULL;
  static const uint64_t static_value2 = 0xda8e23f3a4f7ae68ULL;
};

template<class ContainerAllocator>
struct DataType< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bmirobot_msg/Robot_fdstatus";
  }

  static const char* value(const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32[9] mt_mode\n"
"int32[9] mt_Gpst\n"
"int32[9] mt_Cpst\n"
"int32[9] mt_Lpst\n"
"int32[9] mt_Gspd\n"
"int32[9] mt_Cspd\n"
"int32[9] mt_Lspd\n"
"int32[9] mt_Gtq\n"
"int32[9] mt_PWMduty\n"
"int32[9] mt_Gtime\n"
"int32[9] mt_Ctime\n"
"int32[9] mt_Rtime\n"
"int32[9] mt_sysclk\n"
"int32[9] mt_smptime\n"
"int32[9] mt_cputmp\n"
"int32[9] mt_mttmp\n"
"int32[9] mt_invlt\n"
"int32[9] mt_incrt\n"
"int32[9] mt_PWMfrq\n"
"int32[9] mt_ecd\n"
"int32[9] mt_ecdcnt\n"
;
  }

  static const char* value(const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.mt_mode);
      stream.next(m.mt_Gpst);
      stream.next(m.mt_Cpst);
      stream.next(m.mt_Lpst);
      stream.next(m.mt_Gspd);
      stream.next(m.mt_Cspd);
      stream.next(m.mt_Lspd);
      stream.next(m.mt_Gtq);
      stream.next(m.mt_PWMduty);
      stream.next(m.mt_Gtime);
      stream.next(m.mt_Ctime);
      stream.next(m.mt_Rtime);
      stream.next(m.mt_sysclk);
      stream.next(m.mt_smptime);
      stream.next(m.mt_cputmp);
      stream.next(m.mt_mttmp);
      stream.next(m.mt_invlt);
      stream.next(m.mt_incrt);
      stream.next(m.mt_PWMfrq);
      stream.next(m.mt_ecd);
      stream.next(m.mt_ecdcnt);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Robot_fdstatus_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::bmirobot_msg::Robot_fdstatus_<ContainerAllocator>& v)
  {
    s << indent << "mt_mode[]" << std::endl;
    for (size_t i = 0; i < v.mt_mode.size(); ++i)
    {
      s << indent << "  mt_mode[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_mode[i]);
    }
    s << indent << "mt_Gpst[]" << std::endl;
    for (size_t i = 0; i < v.mt_Gpst.size(); ++i)
    {
      s << indent << "  mt_Gpst[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Gpst[i]);
    }
    s << indent << "mt_Cpst[]" << std::endl;
    for (size_t i = 0; i < v.mt_Cpst.size(); ++i)
    {
      s << indent << "  mt_Cpst[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Cpst[i]);
    }
    s << indent << "mt_Lpst[]" << std::endl;
    for (size_t i = 0; i < v.mt_Lpst.size(); ++i)
    {
      s << indent << "  mt_Lpst[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Lpst[i]);
    }
    s << indent << "mt_Gspd[]" << std::endl;
    for (size_t i = 0; i < v.mt_Gspd.size(); ++i)
    {
      s << indent << "  mt_Gspd[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Gspd[i]);
    }
    s << indent << "mt_Cspd[]" << std::endl;
    for (size_t i = 0; i < v.mt_Cspd.size(); ++i)
    {
      s << indent << "  mt_Cspd[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Cspd[i]);
    }
    s << indent << "mt_Lspd[]" << std::endl;
    for (size_t i = 0; i < v.mt_Lspd.size(); ++i)
    {
      s << indent << "  mt_Lspd[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Lspd[i]);
    }
    s << indent << "mt_Gtq[]" << std::endl;
    for (size_t i = 0; i < v.mt_Gtq.size(); ++i)
    {
      s << indent << "  mt_Gtq[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Gtq[i]);
    }
    s << indent << "mt_PWMduty[]" << std::endl;
    for (size_t i = 0; i < v.mt_PWMduty.size(); ++i)
    {
      s << indent << "  mt_PWMduty[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_PWMduty[i]);
    }
    s << indent << "mt_Gtime[]" << std::endl;
    for (size_t i = 0; i < v.mt_Gtime.size(); ++i)
    {
      s << indent << "  mt_Gtime[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Gtime[i]);
    }
    s << indent << "mt_Ctime[]" << std::endl;
    for (size_t i = 0; i < v.mt_Ctime.size(); ++i)
    {
      s << indent << "  mt_Ctime[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Ctime[i]);
    }
    s << indent << "mt_Rtime[]" << std::endl;
    for (size_t i = 0; i < v.mt_Rtime.size(); ++i)
    {
      s << indent << "  mt_Rtime[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_Rtime[i]);
    }
    s << indent << "mt_sysclk[]" << std::endl;
    for (size_t i = 0; i < v.mt_sysclk.size(); ++i)
    {
      s << indent << "  mt_sysclk[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_sysclk[i]);
    }
    s << indent << "mt_smptime[]" << std::endl;
    for (size_t i = 0; i < v.mt_smptime.size(); ++i)
    {
      s << indent << "  mt_smptime[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_smptime[i]);
    }
    s << indent << "mt_cputmp[]" << std::endl;
    for (size_t i = 0; i < v.mt_cputmp.size(); ++i)
    {
      s << indent << "  mt_cputmp[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_cputmp[i]);
    }
    s << indent << "mt_mttmp[]" << std::endl;
    for (size_t i = 0; i < v.mt_mttmp.size(); ++i)
    {
      s << indent << "  mt_mttmp[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_mttmp[i]);
    }
    s << indent << "mt_invlt[]" << std::endl;
    for (size_t i = 0; i < v.mt_invlt.size(); ++i)
    {
      s << indent << "  mt_invlt[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_invlt[i]);
    }
    s << indent << "mt_incrt[]" << std::endl;
    for (size_t i = 0; i < v.mt_incrt.size(); ++i)
    {
      s << indent << "  mt_incrt[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_incrt[i]);
    }
    s << indent << "mt_PWMfrq[]" << std::endl;
    for (size_t i = 0; i < v.mt_PWMfrq.size(); ++i)
    {
      s << indent << "  mt_PWMfrq[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_PWMfrq[i]);
    }
    s << indent << "mt_ecd[]" << std::endl;
    for (size_t i = 0; i < v.mt_ecd.size(); ++i)
    {
      s << indent << "  mt_ecd[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_ecd[i]);
    }
    s << indent << "mt_ecdcnt[]" << std::endl;
    for (size_t i = 0; i < v.mt_ecdcnt.size(); ++i)
    {
      s << indent << "  mt_ecdcnt[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.mt_ecdcnt[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // BMIROBOT_MSG_MESSAGE_ROBOT_FDSTATUS_H
